---
title: Token Storage
description: Learn how to implement a custom TokenStorage to securely save, access, and clear authentication tokens in Shird.
navigation:
    icon: i-flat-color-icons-data-encryption
seo:
    description: Learn how to implement a custom TokenStorage to securely save, access, and clear authentication tokens in Shird.
---

## Create Your Token Storage

**Shird** needs a secure and flexible way to store and retrieve authentication tokens.
You can use any storage solution you prefer — such as **SharedPreferences**, **Hive**, or **SecureStorage** — by implementing the `TokenStorage` abstraction.

::prose-steps

### Base Interface

Here’s the updated base structure you need to implement:

```ts [token_storage.dart]
import '../models/token_response.dart';

/// Abstract definition for any token storage implementation.
/// Could be SharedPreferences, Hive, SecureStorage, etc.
abstract class TokenStorage {
  /// Saves the authentication tokens.
  Future<void> saveTokens({required TokenResponse tokens});

  /// Returns the JSON token type (e.g., "Bearer"), or null if not stored.
  Future<String?> readTokenType();

  /// Returns the access token, or null if not stored.
  Future<String?> readAccessToken();

  /// Returns the refresh token, or null if not stored.
  Future<String?> readRefreshToken();

  /// Clears all stored tokens.
  Future<void> clear();
}
```

### Why You Need It

The `TokenStorage` abstraction allows **Shird** to securely store tokens and retrieve them automatically for authentication and refresh flows.
By splitting the reading methods into three dedicated functions (`readTokenType`, `readAccessToken`, and `readRefreshToken`), you gain more control and flexibility when interacting with stored credentials.

### Example: Using SharedPreferences

Here’s a simple implementation example using **SharedPreferences**:

```ts [shared_prefs_token_storage.dart]
import 'package:shared_preferences/shared_preferences.dart';
import '../models/token_response.dart';
import 'token_storage.dart';

class SharedPrefsTokenStorage implements TokenStorage {
  static const _accessTokenKey = 'access_token';
  static const _refreshTokenKey = 'refresh_token';
  static const _tokenTypeKey = 'token_type';

  @override
  Future<void> saveTokens({required TokenResponse tokens}) async {
    final prefs = await SharedPreferences.getInstance();
    await prefs.setString(_accessTokenKey, tokens.accessToken);
    if (tokens.refreshToken != null) {
      await prefs.setString(_refreshTokenKey, tokens.refreshToken!);
    }
    if (tokens.tokenType != null) {
      await prefs.setString(_tokenTypeKey, tokens.tokenType!);
    }
  }

  @override
  Future<String?> readAccessToken() async {
    final prefs = await SharedPreferences.getInstance();
    return prefs.getString(_accessTokenKey);
  }

  @override
  Future<String?> readRefreshToken() async {
    final prefs = await SharedPreferences.getInstance();
    return prefs.getString(_refreshTokenKey);
  }

  @override
  Future<String?> readTokenType() async {
    final prefs = await SharedPreferences.getInstance();
    return prefs.getString(_tokenTypeKey);
  }

  @override
  Future<void> clear() async {
    final prefs = await SharedPreferences.getInstance();
    await prefs.remove(_accessTokenKey);
    await prefs.remove(_refreshTokenKey);
    await prefs.remove(_tokenTypeKey);
  }
}
```

### Next Steps

Once your storage implementation is ready, attach it to your `AuthProvider`:

```ts [example.dart]
final authProvider = AuthProvider(
  loginEndpoint: "http://localhost:3000/auth/login",
  refreshEndpoint: "http://localhost:3000/auth/refresh",
  client: DioAuthClient(),
  storage: SharedPrefsTokenStorage(),
);
```

Your tokens will now be securely saved, individually accessible, and automatically managed by **Shird** for login, refresh, and logout operations.
